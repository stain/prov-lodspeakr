# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
#

%{
use W3C::Util::YappDriver;
use W3C::Grammar::YaccCompileTree;
use W3C::Util::Exception;

# START TokenBlock
my $IT__Opt = "_Opt";
my $IT__Plus = "_Plus";
my $IT__Star = "_Star";
my $IT__Q = "_Q";
my $IT__E = "_E";
my $IT__O = "_O";
my $IT__C = "_C";
my $IT__Or = "_Or_";
my $IT__S = "_S";
my $escapedSymbol = "(?:[GI]T_(?:[A-Za-z])+)|(?:(?:(?:(?:[\x{0000}-\\^`-\x{10FFFE}])|(?:__)))+)";
my $PASSED_TOKENS = "(?:[\\t\\n\\r ])+";
my $Tokens = [[0, qr/$PASSED_TOKENS/, undef],
              [0, qr/$IT__Opt/i, 'IT__Opt'],
              [0, qr/$IT__Plus/i, 'IT__Plus'],
              [0, qr/$IT__Star/i, 'IT__Star'],
              [0, qr/$IT__Q/i, 'IT__Q'],
              [0, qr/$IT__E/i, 'IT__E'],
              [0, qr/$IT__O/i, 'IT__O'],
              [0, qr/$IT__C/i, 'IT__C'],
              [0, qr/$IT__Or/i, 'IT__Or'],
              [0, qr/$IT__S/i, 'IT__S'],
              [0, qr/$escapedSymbol/, 'escapedSymbol']];
# END TokenBlock
%}
%%

rule:
    rhselt	{
    my ($self, $rhselt) = @_;
    new W3C::Grammar::YaccCompileTree::Rule($rhselt, undef, undef, $self);
};

rhselt:
    modifiedelt
;

modifiedelt:
    modifiableelt
    | modifiableelt IT__Star
{   my ($self, $modifiableelt, $IT__Star) = @_;
    new W3C::Grammar::YaccCompileTree::Star($modifiableelt, undef, $self);
}
    | modifiableelt IT__Opt
{   my ($self, $modifiableelt, $IT__Opt) = @_;
    new W3C::Grammar::YaccCompileTree::Opt($modifiableelt, undef, $self);
}
    | modifiableelt IT__Plus
{   my ($self, $modifiableelt, $IT__Plus) = @_;
    new W3C::Grammar::YaccCompileTree::Plus($modifiableelt, undef, $self);
}
;

modifiableelt:
    IT__Q escapedSymbol IT__E	{
    my ($self, $IT__Q, $escapedSymbol, $IT__E) = @_;
    $escapedSymbol;
}
    | IT__O rhss IT__C	{
    my ($self, $IT__O, $rhss, $IT__C) = @_;
    $rhss;
};

rhss:
    rhs
    | rhss IT__Or rhs	{
    my ($self, $rhss, $IT__Or, $rhs) = @_;
    $rhss ? 
	W3C::Grammar::YaccCompileTree::Disjunction::addRightBranch($rhss, $rhs, $self) : 
	$rhs;
};

rhs:
    #empty
    | rhselts
;

rhselts:
    rhselt
    | rhselt IT__S rhselts	{
    my ($self, $rhs, $IT__S, $rhselts) = @_;
    new W3C::Grammar::YaccCompileTree::Sequence($rhs, $rhselts, $self);
};





%%

my $LanguageName = 'yackerSymbol';
# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
# START LexerBlock
#
# YappTemplate: used by yacker to create yapp input files.
#
# Use: yacker -l perl -s -n <name> <name>.txt
#
# to generate a yapp input module called Sparql.yp.

##line 11 "YappTemplate"

# $Id: YackerSymbolParser.yp.onDeck,v 1.1 2007-10-18 21:08:35 eric Exp $

package W3C::Grammar::YackerSymbolParser;
require Exporter;
@W3C::Grammar::YackerSymbolParser::ISA = qw(W3C::Grammar::_YackerSymbolParser Exporter);
use vars qw(@EXPORT);
@EXPORT = qw(&test);

use W3C::Util::Exception;
use W3C::Grammar::YaccCompileTree qw($Name2Symbol);

sub _Error {
    my ($self) = @_;
        exists $self->YYData->{ERRMSG}
    and do {
        print $self->YYData->{ERRMSG};
        delete $self->YYData->{ERRMSG};
        return;
    };
    my $pos = pos $self->YYData->{INPUT};
    my $lastPos = $self->YYData->{my_LASTPOS};
    my $excerpt = substr($self->YYData->{INPUT}, $lastPos, $pos - $lastPos);
    my $expect = @{$self->{STACK}} ? join (' | ', sort {(!(lc $a cmp lc $b)) ? $b cmp $a : lc $a cmp lc $b} map {&_terminalString($_)} $self->YYExpect()) : 'INVALID INITIALIZER';
    if (ref $expect) {
	# Flag unexpected (by the author at this point) refs with '?ref'.
	if (ref $expect eq 'HASH') {
	    if (exists $expect->{NEXT}) {
		$expect = $ {$expect->{NEXT}};
	    } else {
		$expect = "?ref {%$expect}";
	    }
	} elsif (ref $expect eq 'ARRAY') {
	    $expect = "?ref [@$expect]";
	} elsif (ref $expect eq 'SCALAR') {
	    $expect = "?ref $$expect";
	} elsif (ref $expect eq 'GLOB') {
	    $expect = "?ref \**$expect";
	} else {
	    $expect = "?ref ??? $expect";
	}
    }
    my $token = &_terminalString($self->YYData->{my_LASTTOKEN});
    my $value = $self->YYData->{my_LASTVALUE};
    die "expected \"$expect\", got ($token, $value) from \"$excerpt\" at offset $lastPos.\n";
}

sub _terminalString { # static
    my ($token) = @_;
    if ($token =~ m{^I_T_(.+)$}) {
	$token = "'$1'";
    } elsif ($token =~ m{^T_(.+)$}) {
	if (my $base = $ARGV[0]) {
	    $token = "&lt;<a href=\"${base}$token\">$1</a>&gt;";
	} else {
	    $token = "<$1>";
	}
    }
    return $token;
}

my $AtStart;

sub _Lexer {
    my($self)=shift;

    my ($token, $value) = ('', undef);

  top:
    if (defined $self->YYData->{INPUT} && 
	pos $self->YYData->{INPUT} < length ($self->YYData->{INPUT})) {
	# still some chars left.
    } else {
	return ('', undef);
    }

    $self->YYData->{my_LASTPOS} = pos $self->YYData->{INPUT};
    my $startPos = pos $self->YYData->{INPUT};
    my ($mText, $mLen, $mI, $mLookAhead) = ('', 0, undef, undef);
    for (my $i = 0; $i < @$Tokens; $i++) {
	my $rule = $Tokens->[$i];
	my ($start, $regexp, $action) = @$rule;
	if ($start && !$AtStart) {
	    next;
	}
	eval {
	    if ($self->YYData->{INPUT} =~ m/\G($regexp)/gc) {
		my $lookAhead = length $2;
		my $len = (pos $self->YYData->{INPUT}) - $startPos + $lookAhead;
		if ($len > $mLen) {
		    $mText = substr($self->YYData->{INPUT}, $startPos, $len - $lookAhead);
		    $mLen = $len;
		    $mI = $i;
		    $mLookAhead = $lookAhead
		}
		pos $self->YYData->{INPUT} = $startPos;
	    }
	}; if ($@) {
	    die "error processing $action: $@";
	}
    }
    if ($mLen) {
	my ($start, $regexp, $action) = @{$Tokens->[$mI]};
	pos $self->YYData->{INPUT} += $mLen - $mLookAhead;
	$AtStart = $mText =~ m/\z/gc;
	($token, $value) = ($action, $mText);
    } else {
	my $excerpt = substr($self->YYData->{INPUT}, pos $self->YYData->{INPUT}, 40);
	die "lexer couldn't parse at \"$excerpt\"\n";
    }
    if (!defined $token) {
	# We just parsed whitespace or comment.
	goto top;
    }
#    my $pos = pos $self->YYData->{INPUT};
#    print "\n$pos,$token,$value\n";
    $self->YYData->{my_LASTTOKEN} = $token;
    $self->YYData->{my_LASTVALUE} = $value;
    &utf8::encode($value);
    my $ret = undef;
    if ($token eq 'escapedSymbol') {
	if ($value =~ m/^IT_(.*)$/) {
	    $ret = new W3C::Grammar::YaccCompileTree::LLITERAL($1, undef, $self);
	} elsif ($value =~ m/^GT_(.*)$/) {
	    if (my $mapped = $Name2Symbol->{$1}) {
		$ret = new W3C::Grammar::YaccCompileTree::LLITERAL($mapped, undef, $self);
	    } else {
		&throw(new W3C::Util::Exception(-message => "no map for \"$1\""));
	    }
	} else {
	    $value =~ s/__/_/g;
	    $ret = new W3C::Grammar::YaccCompileTree::IDENT($value, undef, $self);
	}
    } elsif ($token eq 'IT__Or') {
	$ret = '|';
    }
    return ($token, $ret);
}

sub parse {
    my($self, $symbol) = @_;
    $self->YYData->{INPUT} = $symbol;
    return $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error, yydebug => $ENV{YYDEBUG} );
}

sub test {
    my ($symbol, $langName) = @ARGV[0..1];
    my $parser = new W3C::Grammar::YackerSymbolParser();
    eval {
	&utf8::decode($symbol);
	my $root = $parser->parse($symbol);
	my $text = $root->toString();
	&utf8::encode($text);
	print "$text\n";
    }; if ($@) {if (my $ex = &catch('W3C::Util::Exception')) {
	die $ex->toString;
    } else {die $@;}}
}
# END LexerBlock

1;

__END__

=head1 NAME

W3C::Grammar::YackerSymbolParser - parse intermediate production names generated by Yacker.

=head1 SYNOPSIS

    my ($symbol, $langName) = @ARGV[0..1];
    my $parser = new W3C::Grammar::YackerSymbolParser();
    &utf8::decode($symbol);
    my $root = $parser->parse($symbol);
    my $text = $root->toString(Markup => 'html', LanguageName => $langName);
    &utf8::encode($text);
    print "$text\n";

=head1 DESCRIPTION

Yacker needs to encode rule patterns in [a-zA-Z_]+ so it reserves symbols starting with '_'. This parser reverses the process.

This module is part of the W3C::Grammar CPAN module.

=head1 API

This function supplies a single parsing function. The methods of the returned object are described in W3C::Grammar::YaccCompileTree(1).

=head2 parse($inputString)

Returns a W3C::Grammar::YaccCompileTree::Rule represented by $inputString. $inputString is expected to be [a-zA-Z0-0_]+, though no specific restrictions prevent any of the rest of unicode.

=head1 TESTING/DEBUGGING

    perl -MW3C::Grammar::YackerSymbolParser -e test \
    _Q_O_QOptionalGraphPattern_E_S_QGT_DOT_E_Opt_S_QGroupElement_E_C_E_Opt

which should return

    BrackettedExpression | BuiltInCall | FunctionCall


=head2 longer test

    _Q_O_QGT_EQUAL_E_S_QNumericExpression_E_Or__QGT_NEQUAL_E_S_QNumericExpression_E_Or__QGT_LT_E_S_QNumericExpression_E_Or__QGT_GT_E_S_QNumericExpression_E_Or__QGT_LE_E_S_QNumericExpression_E_Or__QGT_GE_E_S_QNumericExpression_E_C_E_Opt

    ("=" NumericExpression | "!=" NumericExpression | "<" NumericExpression | ">" NumericExpression | "<=" NumericExpression | ">=" NumericExpression)?

With extra args $root->toString(Markup => 'html', LanguageName => 'SPARQL-')
you get:

    ("=" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span> | "!=" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span> | "<" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span> | ">" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span> | "<=" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span> | ">=" <span class="prod"><a class="grammarRef" href="#prod-SPARQL-NumericExpression">NumericExpression</a></span>)?


=head1 BUGS

    _O_QGraphPatternNotTriples_E_S_QGT_DOT_E_Opt_S_QGraphPattern_E_C


=head1 AUTHOR

Eric Prud'hommeaux <eric@w3.org>

=head1 SEE ALSO

W3C::Grammar::YaccCompileTree(1)

=cut
