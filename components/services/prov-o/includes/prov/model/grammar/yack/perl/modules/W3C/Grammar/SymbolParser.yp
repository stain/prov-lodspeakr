# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
# (c) Copyright Francois Desarmenien 1998-2001, all rights reserved.
# (see COPYRIGHT in Parse::Yapp.pm pod section for use and distribution rights)

%{
    #BEGIN {unshift@INC,('../..');}
    use W3C::Util::YappDriver;
    @ISA= qw (W3C::Util::YappDriver);

    use W3C::Util::Exception;
    use W3C::Grammar::YaccCompileTree qw($PassedTokensName);

sub note {}
%}

%{
# START TokenBlock
my $IT__O = "_O";
my $IT__S = "_S";
my $IT__Star = "_Star";
my $IT__Plus = "_Plus";
my $IT__Opt = "_Opt";
my $IT__Q = "_Q";
my $IT__E = "_E";
my $IT__L = "_L";
my $IT__R = "_R";
my $T_Name = "(?:(?:(?:[0-9A-Za-z])|(?:__)))+";
my $PASSED_TOKENS = "eat me";
my $Tokens = [[0, qr/$PASSED_TOKENS/, undef],
              [0, qr/$IT__O/i, 'IT__O'],
              [0, qr/$IT__S/i, 'IT__S'],
              [0, qr/$IT__Star/i, 'IT__Star'],
              [0, qr/$IT__Plus/i, 'IT__Plus'],
              [0, qr/$IT__Opt/i, 'IT__Opt'],
              [0, qr/$IT__Q/i, 'IT__Q'],
              [0, qr/$IT__E/i, 'IT__E'],
              [0, qr/$IT__L/i, 'IT__L'],
              [0, qr/$IT__R/i, 'IT__R'],
              [0, qr/$T_Name/, 'T_Name']];
# END TokenBlock
%}
%%

Disjunction:
    Sequence _Q_L_Q_O_E_S_QSequence_E_R_EStar	
{
    my ($self, $Sequence, $_Q_L_Q_O_E_S_QSequence_E_R_EStar) = @_;
    print TRACE "  Disjunction:\n      Sequence _Q_L_Q_O_E_S_QSequence_E_R_EStar\n";
    &note("$Sequence $_Q_L_Q_O_E_S_QSequence_E_R_EStar");
    return $_Q_L_Q_O_E_S_QSequence_E_R_EStar ? 
	W3C::Grammar::YaccCompileTree::Disjunction::addRightBranch($Sequence, $_Q_L_Q_O_E_S_QSequence_E_R_EStar, $self) : 
	$Sequence;
};

_L_Q_O_E_S_QSequence_E_R:
    IT__O Sequence	
{
    my ($self, $_O, $Sequence) = @_;
    print TRACE "  _L_Q_O_E_S_QSequence_E_R:\n      _O Sequence\n";
    &note("$_O $Sequence");
    return $Sequence;
};

_Q_L_Q_O_E_S_QSequence_E_R_EStar:
    
{
    my ($self, ) = @_;
    print TRACE "  _Q_L_Q_O_E_S_QSequence_E_R_EStar:\n      \n";
    &note("");
    return undef;
}
    | _Q_L_Q_O_E_S_QSequence_E_R_EStar _L_Q_O_E_S_QSequence_E_R	
{
    my ($self, $_Q_L_Q_O_E_S_QSequence_E_R_EStar, $_L_Q_O_E_S_QSequence_E_R) = @_;
    print TRACE "  _Q_L_Q_O_E_S_QSequence_E_R_EStar:\n      _Q_L_Q_O_E_S_QSequence_E_R_EStar _L_Q_O_E_S_QSequence_E_R\n";
    &note("$_Q_L_Q_O_E_S_QSequence_E_R_EStar $_L_Q_O_E_S_QSequence_E_R");
    return $_Q_L_Q_O_E_S_QSequence_E_R_EStar ? 
	new W3C::Grammar::YaccCompileTree::Sequence($_Q_L_Q_O_E_S_QSequence_E_R_EStar, $_L_Q_O_E_S_QSequence_E_R, $self) :
	$_L_Q_O_E_S_QSequence_E_R;
};

Sequence:
    modifiedelt _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar	
{
    my ($self, $modifiedelt, $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar) = @_;
    print TRACE "  Sequence:\n      modifiedelt _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar\n";
    &note("$modifiedelt $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar");
    return $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar ? 
	new W3C::Grammar::YaccCompileTree::Sequence($modifiedelt, $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar, $self) :
	$modifiedelt;
};

_L_Q_S_E_S_Qmodifiedelt_E_R:
    IT__S modifiedelt	
{
    my ($self, $_S, $modifiedelt) = @_;
    print TRACE "  _L_Q_S_E_S_Qmodifiedelt_E_R:\n      _S modifiedelt\n";
    &note("$_S $modifiedelt");
    return $modifiedelt;
};

_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar:
    
{
    my ($self, ) = @_;
    print TRACE "  _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar:\n      \n";
    &note("");
    return undef;
}
    | _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar _L_Q_S_E_S_Qmodifiedelt_E_R	
{
    my ($self, $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar, $_L_Q_S_E_S_Qmodifiedelt_E_R) = @_;
    print TRACE "  _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar:\n      _Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar _L_Q_S_E_S_Qmodifiedelt_E_R\n";
    &note("$_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar $_L_Q_S_E_S_Qmodifiedelt_E_R");
    return $_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar ? 
	new W3C::Grammar::YaccCompileTree::Sequence($_Q_L_Q_S_E_S_Qmodifiedelt_E_R_EStar, $_L_Q_S_E_S_Qmodifiedelt_E_R, $self) :
	$_L_Q_S_E_S_Qmodifiedelt_E_R;
};

modifiedelt:
    modifiableelt	
{
    my ($self, $modifiableelt) = @_;
    print TRACE "  modifiedelt:\n      modifiableelt\n";
    &note("$modifiableelt");
    return $modifiableelt;
}
    | modifiableelt IT__Star	
{
    my ($self, $modifiableelt, $_Star) = @_;
    print TRACE "  modifiedelt:\n      modifiableelt _Star\n";
    &note("$modifiableelt $_Star");
    return new W3C::Grammar::YaccCompileTree::Star($modifiableelt, $_Star, $self);
}
    | modifiableelt IT__Plus	
{
    my ($self, $modifiableelt, $_Plus) = @_;
    print TRACE "  modifiedelt:\n      modifiableelt _Plus\n";
    &note("$modifiableelt $_Plus");
    return new W3C::Grammar::YaccCompileTree::Plus($modifiableelt, $_Plus, $self);
}
    | modifiableelt IT__Opt	
{
    my ($self, $modifiableelt, $_Opt) = @_;
    print TRACE "  modifiedelt:\n      modifiableelt _Opt\n";
    &note("$modifiableelt $_Opt");
    return new W3C::Grammar::YaccCompileTree::Opt($modifiableelt, $_Opt, $self);
};

modifiableelt:
    Symb	
{
    my ($self, $Symb) = @_;
    print TRACE "  modifiableelt:\n      Symb\n";
    &note("$Symb");
    return $Symb;
}
    | Group	
{
    my ($self, $Group) = @_;
    print TRACE "  modifiableelt:\n      Group\n";
    &note("$Group");
    return new W3C::Grammar::YaccCompileTree::Group('(', $Group, $self)
};

Symb:
    IT__Q T_Name IT__E	
{
    my ($self, $_Q, $T_Name, $_E) = @_;
    print TRACE "  Symb:\n      _Q T_Name _E\n";
    &note("$_Q $T_Name $_E");
    return new W3C::Grammar::YaccCompileTree::Symb(
	   new W3C::Grammar::YaccCompileTree::LLITERAL($T_Name, 0, $self), $self);
};

Group:
    IT__L Disjunction IT__R	
{
    my ($self, $_L, $Disjunction, $_R) = @_;
    print TRACE "  Group:\n      _L Disjunction _R\n";
    &note("$_L $Disjunction $_R");
    return $Disjunction;
};
%%

my $LanguageName = 'SymbolParser';
# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
# START LexerBlock
#
# YappTemplate: used by yacker to create yapp input files.
#
# Use: yacker -l perl -s -n <name> <name>.txt
#
# to generate a yapp input module called Sparql.yp.

#line 12 "YappTemplate"

# $Id: SymbolParser.yp,v 1.1 2006-06-15 23:45:05 eric Exp $

sub _Error {
    my ($self) = @_;
        exists $self->YYData->{ERRMSG}
    and do {
        print $self->YYData->{ERRMSG};
        delete $self->YYData->{ERRMSG};
        return;
    };
    my $pos = pos $self->YYData->{INPUT};
    my $lastPos = $self->YYData->{my_LASTPOS};
    my $excerpt = substr($self->YYData->{INPUT}, $lastPos, $pos - $lastPos);
    my $expect = @{$self->{STACK}} ? join (' | ', sort {(!(lc $a cmp lc $b)) ? $b cmp $a : lc $a cmp lc $b} map {&_terminalString($_)} $self->YYExpect()) : 'INVALID INITIALIZER';
    if (ref $expect) {
	# Flag unexpected (by the author at this point) refs with '?ref'.
	if (ref $expect eq 'HASH') {
	    if (exists $expect->{NEXT}) {
		$expect = $ {$expect->{NEXT}};
	    } else {
		$expect = "?ref {%$expect}";
	    }
	} elsif (ref $expect eq 'ARRAY') {
	    $expect = "?ref [@$expect]";
	} elsif (ref $expect eq 'SCALAR') {
	    $expect = "?ref $$expect";
	} elsif (ref $expect eq 'GLOB') {
	    $expect = "?ref \**$expect";
	} else {
	    $expect = "?ref ??? $expect";
	}
    }
    my $token = &_terminalString($self->YYData->{my_LASTTOKEN});
    my $value = $self->YYData->{my_LASTVALUE};
    die "expected \"$expect\", got ($token, $value) from \"$excerpt\" at offset $lastPos.\n";
}

sub _terminalString { # static
    my ($token) = @_;
    if ($token =~ m{^I_T_(.+)$}) {
	$token = "'$1'";
    } elsif ($token =~ m{^T_(.+)$}) {
	if (my $base = $ARGV[0]) {
	    $token = "&lt;<a href=\"${base}$token\">$1</a>&gt;";
	} else {
	    $token = "<$1>";
	}
    }
    return $token;
}

my $AtStart;

sub _Lexer {
    my($self)=shift;

    my ($token, $value) = ('', undef);

  top:
    if (defined $self->YYData->{INPUT} && 
	pos $self->YYData->{INPUT} < length ($self->YYData->{INPUT})) {
	# still some chars left.
    } else {
	return ('', undef);
    }

    $self->YYData->{my_LASTPOS} = pos $self->YYData->{INPUT};
    my $startPos = pos $self->YYData->{INPUT};
    my ($mText, $mLen, $mI, $mLookAhead) = ('', 0, undef, undef);
    for (my $i = 0; $i < @$Tokens; $i++) {
	my $rule = $Tokens->[$i];
	my ($start, $regexp, $action) = @$rule;
	if ($start && !$AtStart) {
	    next;
	}
	eval {
	    if ($self->YYData->{INPUT} =~ m/\G($regexp)/gc) {
		my $lookAhead = length $2;
		my $len = (pos $self->YYData->{INPUT}) - $startPos + $lookAhead;
		if ($len > $mLen) {
		    $mText = substr($self->YYData->{INPUT}, $startPos, $len - $lookAhead);
		    $mLen = $len;
		    $mI = $i;
		    $mLookAhead = $lookAhead
		}
		pos $self->YYData->{INPUT} = $startPos;
	    }
	}; if ($@) {
	    die "error processing $action: $@";
	}
    }
    if ($mLen) {
	my ($start, $regexp, $action) = @{$Tokens->[$mI]};
	pos $self->YYData->{INPUT} += $mLen - $mLookAhead;
	$AtStart = $mText =~ m/\z/gc;
	($token, $value) = ($action, $mText);
    } else {
	my $excerpt = substr($self->YYData->{INPUT}, pos $self->YYData->{INPUT}, 40);
	die "lexer couldn't parse at \"$excerpt\"\n";
    }
    if (!defined $token) {
	# We just parsed whitespace or comment.
	goto top;
    }
#    my $pos = pos $self->YYData->{INPUT};
#    print "\n$pos,$token,$value\n";
    $self->YYData->{my_LASTTOKEN} = $token;
    $self->YYData->{my_LASTVALUE} = $value;
    &utf8::encode($value);
    print TRACE "shift ($token, $value)\n";
    return ($token, $value);
}

sub parse {
    my ($self, @args) = @_;
    $self->YYData->{NEXT} = undef;
    $self->YYData->{CreateNovelBNodes} = 0;
    return $self->SUPER::parse(@args);
}

# Provide (one) chunk of text to parse.
sub nextChunk {
    my ($self) = @_;
    #return shift (@{$self->YYData->{my_CHUNKS}});
    #return shift (@ARGV);
    return <STDIN>;
}

# Handy debugging wrapper for calling semantics actions.
sub _wrap {
    my ($self, $obj, $method, @args) = @_;
    my @ret;
    eval {
	@ret = $obj->$method(@args);
    }; if ($@) {if (my $ex = &catch('W3C::Util::CachedContextException')) {
	&throw($ex);;
    } elsif ($ex = &catch('W3C::Util::Exception')) {
	my $newEx = new 
	    W3C::Util::CachedContextException(-str => $self->YYData->{INPUT}, 
					      -pos => $self->YYData->{my_LASTPOS}+1, 
					      -errorMessage => $ex->toString);
	$newEx->assumeStackTrace($ex);
	&throw($newEx);
    } else {
	my $newEx = 
	    new W3C::Util::CachedContextException(-str => $self->YYData->{INPUT}, 
						  -pos => $self->YYData->{my_LASTPOS}+1, 
						  -errorMessage => "$obj->$method: $@");
	&throw($newEx);
    }}
    return wantarray ? @ret : $ret[-1];
}

sub printArgs {
    my ($self) = @_;
    return;
    print ':';
    foreach my $arg (@_) {
	print " $arg";
    }
    print ' Curtok:',$self->YYCurtok;
    print ' Curval:',$self->YYCurval;
    print ' Expect:',$self->YYExpect;
    print ' Lexer:',$self->YYLexer;
    print ' Data:',$self->YYData;
    print "\n";
}

# Used by -M invocation:
#   perl -MW3C::Rdf::SparqlParser -e '(new W3C::Rdf::RLSparqlParser())->Run' '...'
sub main {
    my ($self) = @_;
    $self->Run();
}


package W3C::Grammar::SymbolParser;
@W3C::Grammar::SymbolParser::ISA = qw(W3C::Grammar::_SymbolParser);
sub new {
    my ($proto, $brqlString, $algae2, $location, %flags) = @_;
    my $class = ref($proto) || $proto;
    my $self = $class->SUPER::new();
    $self->YYData->{INPUT} = $brqlString;
    $self->YYData->{LOCATION} = $location;
 
    $self->YYData->{ALGAE2} = $algae2;
    $self->YYData->{QNAMES} = [];
    $self->YYData->{FLAGS} = {%flags};
    return $self;
}

sub nextChunk {
    my ($self) = @_;
    my $ret = $self->YYData->{SYMBOL_STRING};
    $self->YYData->{SYMBOL_STRING} = undef;
    return $ret;
}

# Interactive ReadLine parser -- under development

# perl -MW3C::Rdf::SparqlParser -e '(new W3C::Rdf::RLSparqlParser())->Run' 'asdf'
# b /usr/share/perl5/Parse/Yapp/Driver.pm:343

##!/usr/bin/perl
#BEGIN {unshift@INC,('../..');}
#use W3C::Rdf::SparqlParser;
#$p = new W3C::Rdf::RLSparqlParser();
#$p->main;

#./SparqlParser "(ask '(<ab:cd> (?asdf ?s ?o)) assert '(ef:gh (?a ?b ?c)))"

1;

__END__

=head1 NAME

W3C::Rdf::SparqlParser - a Parse::Yapp grammer for the SPARQL language

=head1 SYNOPSIS

  use W3C::Rdf::SparqlParser;
  my $p = new W3C::Rdf::SparqlParser($brqlString, $query, "query.txt");
  my $actions = $p->parse($debug);
  foreach my $action (@$actions) {
    $action->delayedEvaluate($self->{RESULT_SET});
  }
  return $self->getReport();

=head1 DESCRIPTION

The SparqlParser module binds a yapp grammar to semantic actions that build an
AlgaeCompileTree. In general, client applicatiosn have no direct interaction
with SparqlParser. Devlopers wishing to extend the SPARQL query language
  http://www.w3.org/2001/sw/DataAccess/rq23/

will need the perl yapp modules. The Makefile included with the W3C::Rdf CPAN
module has a target to re-compile the SparqlParser grammar. Invoke this with
  make SparqlParser.pm
It is likely that someone extending the SparqlParser grammar will also want to
extended AlgaeCompileTree.

This module is part of the W3C::Rdf CPAN module.

=head1 AUTHOR

Eric Prud\'hommeaux <eric@w3.org>

=head1 SEE ALSO

W3C::Rdf::AlgaeCompileTree(3) W3C::Rdf::Algae2(3) perl(1).

=cut
